<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Group Meeting Locator</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      display: flex;
      height: 100vh;
    }
    #sidebar {
      width: 300px;
      padding: 1em;
      background: #f4f4f4;
      overflow-y: auto;
    }
    #map {
      flex: 1;
    }
    .person-input {
      display: flex;
      flex-direction: column;
      margin-bottom: 1em;
    }
    .person-input .top-row {
      display: flex;
    }
    .person-input input {
      flex: 1;
      margin-right: 0.5em;
    }
    .distance {
      font-size: 0.9em;
      color: #555;
      margin-top: 0.2em;
    }
    #total-distance {
      font-weight: bold;
      margin-top: 1em;
    }
    .error-message {
      color: red;
      font-size: 0.9em;
      margin-top: 0.2em;
    }
  </style>
</head>
<body>
  <div id="sidebar">
    <h2>People & Locations</h2>
    <div id="inputs"></div>
    <button onclick="addPersonInput()">Add Person</button>
    <button onclick="updateMap()">Update Map</button>
    <div id="total-distance">Total Distance: –</div>
  </div>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>
  <script>
    let map = L.map('map').setView([0, 0], 2);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: 'Map data © <a href="https://openstreetmap.org">OpenStreetMap</a> contributors'
    }).addTo(map);

    let personCount = 0;
    let personInputs = document.getElementById('inputs');
    let markers = [];
    let meanMarker = null;
    let coords = [];
    let heatLayer = null;
    const totalDistanceElem = document.getElementById('total-distance');

    function saveInputsToLocalStorage() {
      const values = Array.from(document.querySelectorAll('#inputs input')).map(input => input.value.trim());
      localStorage.setItem('locations', JSON.stringify(values));
    }

    function loadInputsFromLocalStorage() {
      const saved = JSON.parse(localStorage.getItem('locations') || '[]');
      saved.forEach(value => addPersonInput(value));
    }

    function addPersonInput(value = '') {
      const div = document.createElement('div');
      div.className = 'person-input';
      div.innerHTML = `
        <div class="top-row">
          <input type="text" placeholder="Location" id="person-${personCount}" value="${value}" onchange="saveInputsToLocalStorage()" />
          <button onclick="this.parentElement.parentElement.remove(); saveInputsToLocalStorage();">X</button>
        </div>
        <div class="distance" id="distance-${personCount}">Distance: –</div>
        <div class="error-message" id="error-${personCount}"></div>
      `;
      personInputs.appendChild(div);
      personCount++;
    }

    async function geocodeLocation(location) {
      const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(location)}`;
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('Network error');
        const data = await response.json();
        if (data.length === 0) return null;
        return {
          lat: parseFloat(data[0].lat),
          lon: parseFloat(data[0].lon),
          display_name: data[0].display_name
        };
      } catch (error) {
        console.error('Geocoding error:', error);
        return null;
      }
    }

    function computeDistance(latlng1, latlng2) {
      return map.distance(latlng1, latlng2) / 1000;
    }

    async function updateMap() {
      markers.forEach(marker => map.removeLayer(marker));
      markers = [];
      coords = [];

      const inputs = document.querySelectorAll('#inputs input');
      const distances = document.querySelectorAll('.distance');
      const errors = document.querySelectorAll('.error-message');

      for (let i = 0; i < inputs.length; i++) {
        const input = inputs[i];
        const value = input.value.trim();
        const distanceElem = distances[i];
        const errorElem = errors[i];

        errorElem.textContent = '';
        distanceElem.textContent = 'Distance: –';

        if (!value) continue;

        const result = await geocodeLocation(value);
        if (result) {
          const marker = L.marker([result.lat, result.lon])
            .addTo(map)
            .bindPopup(result.display_name);
          markers.push(marker);
          coords.push({ lat: result.lat, lon: result.lon, distanceElem });
        } else {
          errorElem.textContent = 'Location not found.';
        }
      }

      if (meanMarker) map.removeLayer(meanMarker);
      if (heatLayer) map.removeLayer(heatLayer);

      if (coords.length > 0) {
        const latMean = coords.reduce((sum, c) => sum + c.lat, 0) / coords.length;
        const lonMean = coords.reduce((sum, c) => sum + c.lon, 0) / coords.length;

        meanMarker = L.marker([latMean, lonMean], {
          draggable: true,
          icon: L.icon({
            iconUrl: 'https://maps.gstatic.com/mapfiles/ms2/micons/red-dot.png',
            iconSize: [32, 32],
            iconAnchor: [16, 32]
          })
        })
        .addTo(map)
        .bindPopup('Mean Location')
        .on('drag', () => updateDistances(meanMarker.getLatLng()));

        map.setView([latMean, lonMean], 6);

        updateDistances({ lat: latMean, lng: lonMean });
        addHeatMapAround([latMean, lonMean]);
      } else {
        map.setView([0, 0], 2);
        totalDistanceElem.textContent = 'Total Distance: –';
      }
    }

    function updateDistances(center) {
      let total = 0;
      coords.forEach(c => {
        const dist = computeDistance(center, { lat: c.lat, lng: c.lon });
        total += dist;
        c.distanceElem.textContent = `Distance: ${dist.toFixed(1)} km`;
      });
      totalDistanceElem.textContent = `Total Distance: ${total.toFixed(1)} km`;
    }

    function addHeatMapAround(center) {
      const bounds = map.getBounds();
      const step = 0.2;
      const heatData = [];
      const values = [];

      for (let lat = bounds.getSouth(); lat <= bounds.getNorth(); lat += step) {
        for (let lon = bounds.getWest(); lon <= bounds.getEast(); lon += step) {
          let totalDist = 0;
          coords.forEach(c => {
            totalDist += computeDistance({ lat, lng: lon }, { lat: c.lat, lng: c.lon });
          });
          values.push(totalDist);
          heatData.push([lat, lon, totalDist]);
        }
      }

      const min = Math.min(...values);
      const max = Math.max(...values);

      const normalizedData = heatData.map(([lat, lon, val]) => [lat, lon, (val - min) / (max - min)]);

      heatLayer = L.heatLayer(normalizedData, {
        radius: 25,
        blur: 15,
        maxZoom: 12,
        gradient: { 0.0: 'green', 0.5: 'yellow', 1.0: 'red' }
      }).addTo(map);
    }

    loadInputsFromLocalStorage();
    if (personCount === 0) addPersonInput();
  </script>
</body>
</html>
